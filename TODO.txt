BackEndTicky - TODO List
========================
Last Updated: October 26, 2025

ACTIVE TASKS:
-------------
- Further optimize lag reduction (Optional)
  → Goal: Investigate and improve perceived lag between clicking Correct/Skip and seeing next word
  → Current State: 
    * Word preloading system already implemented (should be ~0ms delay)
    * 15-word queue sent at turn start
    * Client shows next word instantly from local queue
    * Server processes in background
    * Auto-refill when ≤8 words remaining
  → Potential Issues to Investigate:
    * Is button debouncing too long? (currently 200ms)
    * Network conditions on Railway deployment (2-3s round-trip measured)
    * Are there any blocking operations in client-side word handling?
    * Does score update cause re-render lag?
    * Mobile device performance (primary use case)
    * Is optimistic update working correctly on all devices?
  → Areas to Test:
    * Test on actual mobile devices (not just desktop)
    * Test on slow network (throttle in DevTools)
    * Measure actual delay with console timestamps
    * Check if all browsers handle optimistic updates correctly
    * Test with rapid clicking (multiple words quickly)
  → Potential Improvements:
    * Reduce button debounce if network lag isn't causing issues
    * Add visual feedback animation (word slide out/in) to mask any delay
    * Preload MORE words (currently 15) if queue depletes too fast
    * Use requestAnimationFrame for smoother transitions
    * Optimize React re-renders (useMemo, useCallback)
    * Add haptic feedback on mobile for immediate tactile response
  → Priority: Medium-High (affects core gameplay experience)
  → Note: Already significantly improved from initial 1200ms debounce, but worth revisiting

- Improve "Play Again" Functionality
  → Goal: Create a new game with same players and settings when clicking "Play Again"
  → Current State: Both "Play Again" and "Back to Home" just navigate to home screen (redundant)
  → Desired Behavior:
    * Create new game with same gameSettings from previous game
    * Copy all players from previous game to new game
    * Maintain team assignments from previous game
    * Place everyone in lobby (not auto-start)
    * Allow host to modify settings before starting if desired
    * Handle missing players gracefully:
      - Players who don't rejoin are marked as "pending" or removed
      - Game can still start with remaining players
      - Maybe show "Waiting for [PlayerName]..." with timeout
  → Implementation:
    * Add "rematch" socket action or REST endpoint
    * Backend creates new game, copies settings and player list
    * Backend returns new gameId
    * Frontend navigates all players to new lobby: /lobby/{newGameId}
    * Optional: Add "rejoin" mechanism so missing players can join later
  → UI Considerations:
    * Show loading state while creating rematch
    * Notify players "Starting rematch..." 
    * Handle case where some players left / disconnected
  → Priority: Medium (nice UX improvement, not critical)

- Add "All Play" Feature
  → Goal: Special round where everyone guesses (only one describer)
  → Mechanics:
    * Random trigger or specific frequency (every N turns?)
    * Single word display
    * All players on BOTH teams can guess (except describer)
    * First team to guess correctly wins the points
    * Opposing team can "steal" by guessing correctly
  → UI Changes:
    * Special "ALL PLAY!" screen/indicator
    * All players see word simultaneously (except describer)
    * First correct answer wins
  → Considerations:
    * How to handle simultaneous guesses? (timestamp-based)
    * Point value (higher stakes for All Play?)
    * Should describer rotate normally or stay same?
    * How to trigger: Random chance? Fixed interval? Last turn?
  → Priority: Medium (exciting feature, but complex)
  → Schema: Need to track All Play state in currentTurn

- Add "First to X" Game Mode
  → Goal: Play until one team reaches X points (instead of fixed rounds)
  → Settings:
    * Target score: 10, 15, 20, 25, 30, 50 points
    * Add to game settings: firstToX (boolean), targetScore (number)
  → Logic Changes:
    * Check after each turn if any team >= targetScore
    * End game when condition met (instead of after totalRounds)
    * Still alternate teams as normal
  → UI Changes:
    * Game creation: Toggle "First to X" mode, set target score
    * During game: Show progress toward target (e.g., "15/25")
    * Ready screen: "Next to X points!" instead of "Round Y of Z"
  → Considerations:
    * Should this be a separate app/game type? (Probably not, just a mode)
    * Risk: Requires changes to core game loop (endTurn logic)
    * Testing: Need to ensure no conflicts with existing round-based logic
    * What if teams tie at same score? (Play one more turn? Sudden death?)
  → Priority: Medium (popular request, moderate complexity)
  → CAUTION: Changes affect core game flow - test thoroughly before deploying

- Combine "All Play" + "First to X"
  → Goal: In "First to X" mode, the final turn is always an All Play
  → Mechanics:
    * When a team is 1 turn away from winning (within winning distance)
    * Trigger All Play for dramatic finish
    * Winner-takes-all final round
  → Logic:
    * Check before each turn: is current team close enough to win?
    * If yes, convert next turn to All Play
    * If All Play is won, game over
    * If All Play is lost, continue until someone reaches target
  → Considerations:
    * What's "winning distance"? (1 turn's worth of points? configurable?)
    * Should losing team get a chance to tie? (Fairness)
    * Very exciting for players - high stakes ending
  → Priority: Low (requires both previous features first)
  → Implementation: Build All Play first, then First to X, then combine

- Add Settings Panel for Game Creator
  → Allow host to customize game settings before starting
  → Location: LobbyScreen.jsx (add expandable settings panel)
  → Settings to expose:
    * Turn duration (15s, 30s, 45s, 60s) - currently hardcoded to 30s
    * Total rounds (1-10) - currently hardcoded to 3
    * Skips per turn (0-5) - currently hardcoded to 1
    * Penalty for extra skip (0-3) - currently hardcoded to 1
    * Enable/disable hints - NEW
    * Hints per turn (0-3) - NEW
  → Store in game.gameSettings (already exists, just expose to UI)
  → UI: Collapsible "Game Settings" section in lobby with dropdowns/sliders
  → Mobile: Keep compact, use <select> elements instead of custom dropdowns

- Consider "The Hat Game" Implementation
  → Goal: Similar game where players submit their own words instead of using word database
  → Classic Rules:
    * Each player submits 3-5 words/phrases written on paper ("in the hat")
    * Round 1: Describe word without saying it (like current game)
    * Round 2: Same words, but only ONE WORD clues allowed
    * Round 3: Same words, but CHARADES only (no talking)
    * Points: Team that guesses correctly gets the point
    * All players' words mixed together and used by all teams
  → Key Differences from BackEndTicky:
    * User-generated content instead of database
    * Multiple rounds with SAME words but different rules
    * No categories (just random words)
    * More party-game oriented
  → Implementation Options:
    
    **OPTION A: Separate App (Recommended)**
    Pros:
      ✅ Clean separation of concerns
      ✅ Independent deployment and updates
      ✅ Easier to maintain and debug
      ✅ Can have different branding/UI
      ✅ Users choose which game they want to play
      ✅ Simpler codebase for each game
    Cons:
      ❌ Code duplication (Socket.IO setup, user management, teams)
      ❌ Two separate deployments to maintain
      ❌ Can't easily switch between games mid-session
      ❌ Two separate MongoDB collections/databases
    
    **OPTION B: Multiple Games in One App**
    Pros:
      ✅ Shared infrastructure (Socket.IO, MongoDB, teams, lobby)
      ✅ Single deployment to maintain
      ✅ Could switch game modes in same session
      ✅ Shared UI components and styles
      ✅ One codebase to update
    Cons:
      ❌ More complex codebase (game mode switches everywhere)
      ❌ Harder to test (more conditional logic)
      ❌ Schema needs to support both game types
      ❌ Risk of breaking one game while updating the other
      ❌ Harder for novice coder to understand
    
    **OPTION C: Modular Architecture (Future-Proof)**
    Structure:
      /shared/multiplayer-core/
        - Socket.IO setup, rooms, broadcasting
        - User management (join, leave, teams)
        - Base game schema (id, status, teams, players)
      /games/word-guesser/    (BackEndTicky)
        - Word database and categories
        - Turn logic specific to word guessing
      /games/hat-game/
        - User word submission
        - Multi-round logic (describe/one-word/charades)
      /client/
        - Shared components (Lobby, Teams, Timer)
        - Game-specific components in subfolders
    Pros:
      ✅ Best of both worlds
      ✅ Reusable infrastructure
      ✅ Easy to add more games later
      ✅ Clean separation per game
      ✅ Shared code is actually shared
    Cons:
      ❌ Significant upfront refactoring needed
      ❌ Complex initial setup
      ❌ Overkill if only planning 2 games
      ❌ Harder for novice coder initially
  
  → Recommendation:
    * SHORT TERM: Build as separate app (Option A)
      - Get Hat Game working independently
      - Learn what infrastructure actually needs to be shared
      - Keep BackEndTicky stable and production-ready
    * LONG TERM: If building 3+ games, refactor to modular (Option C)
      - Extract common multiplayer infrastructure
      - Each game becomes a "plugin"
      - Worth the refactoring effort at that point
  
  → Technical Considerations:
    * Hat Game needs: Word submission UI, round tracking, rule changes per round
    * Different timer rules (usually longer rounds)
    * Need to store submitted words per game (not global database)
    * Clear words after game ends (privacy/cleanup)
  
  → Priority: Low (interesting idea, but current game is working well)
  → Next Steps: Build Hat Game as separate repo, reuse learnings from BackEndTicky

- Architecture Refactor: Modular Game System
  → Goal: Extract user management and multiplayer infrastructure so it can be reused for other games
  → Current structure: Everything is tightly coupled to word-guessing game logic
  → Proposed structure:
    /shared/                       # Reusable multiplayer infrastructure
      /models/BaseGame.js          # Common game fields (id, status, teams, players)
      /handlers/userManagement.js  # Join game, join team, leave game
      /handlers/socketSetup.js     # Socket.IO connection, rooms, broadcasting
    /games/
      /word-guesser/               # Current game (BackEndTicky)
        /models/WordGame.js        # Extends BaseGame, adds word-specific fields
        /handlers/wordHandlers.js  # Game-specific logic (start turn, word correct, etc.)
        /data/words.js             # Word lists
      /future-game-1/              # Future game can reuse /shared/
      /future-game-2/
  → Benefits:
    * Reuse user management, team joining, lobby logic
    * Reuse Socket.IO setup and room management
    * Each game only implements its unique gameplay logic
    * Easier to maintain multiple games
  → Considerations:
    * Breaking change - requires significant refactoring
    * Need to ensure backward compatibility with existing database
    * Test thoroughly before deploying
  → Priority: Medium (good for future, but current system works)
  → See ARCHITECTURE.md for current structure before refactoring


COMPLETED TASKS:
----------------
[DONE - Oct 26, 2025] Reduce lag for guessers (Broadcast First, Save Later)
  → Implemented Option 1: Broadcast game updates immediately, save to database in background
  → Created fast versions of handlers: handleWordCorrectFast, handleWordSkipFast, handleUseHintFast
  → Word actions (correct/skip/hint) now broadcast immediately without waiting for MongoDB save
  → Database save happens in background (fire-and-forget with error logging)
  → Expected lag reduction: ~100-500ms → ~10-50ms for guessers
  → Trade-off: Tiny risk of data loss if server crashes between broadcast and save (acceptable)
  → Original handlers kept for reference (not currently used)
  → Files changed: server/index.js
  → Result: All players should now see updates much faster (closer to describer's instant experience)

[DONE - Oct 26, 2025] Auto-save settings when starting game
  → Implemented Option B: Auto-save settings on "Start Game" click
  → If host has settings panel open in edit mode, settings are saved before game starts
  → Added 100ms delay to ensure settings are saved before game initialization
  → File changed: client/src/components/LobbyScreen.jsx (handleStartGame function)
  → Result: No more lost/unsaved settings when starting game

[DONE - Oct 26, 2025] Fixed skip penalty not respecting gameSettings
  → Bug: Penalty was hardcoded to -1 point instead of using gameSettings.penaltyForExtraSkip
  → Solution: Changed handleWordSkip to read penalty value from game.gameSettings.penaltyForExtraSkip
  → File changed: server/index.js (handleWordSkip function)
  → Result: Setting penalty to 0, 2, or 3 points now works correctly

[DONE - Oct 26, 2025] Fixed "Round 4 of 3" display issue after final turn
  → Solution: Conditionally hide round counter in ReadyScreen.jsx when game.status === 'finished'
  → File changed: client/src/components/ReadyScreen.jsx
  → Result: No more confusing round counter after game completes

[DONE - Oct 26, 2025] Added Settings Panel in Lobby
  → Game host can now customize settings before starting game
  → Settings: Turn Duration (15-120s), Total Rounds (1-10), Skips per Turn (0-5), 
    Penalty for Extra Skip (0-3), Hints per Turn (0-5)
  → Host sees "Edit" button with editable form controls
  → Non-host players see read-only display
  → Mobile-friendly using native select/input elements
  → Backend: Added handleUpdateGameSettings with validation
  → Backend: Only allows updates in lobby (before game starts)
  → Files changed: 
    * client/src/components/LobbyScreen.jsx (UI)
    * server/index.js (handler + socket action)
  → Result: Users can customize gameplay without code changes

[DONE - Oct 22, 2025] Fixed turn rotation bug (teams playing twice in a row)
  → Root cause: Concurrent handleEndTurn calls from multiple clients when timer expired
  → Solution: Added concurrency guard (isEndingTurn flag) to prevent duplicate processing
  → Also fixed: Navigation race condition in LobbyScreen (removed duplicate navigate call)
  → Result: Teams now properly alternate with no skipping or double turns
  → See: BUG_ANALYSIS_TURN_ROTATION.md for full technical details

[DONE - Oct 22, 2025] Implemented Hint System
  → Describer gets 2 hints per turn (configurable via gameSettings.hintsPerTurn)
  → Hint button shows remaining hints: "💡 Hint (2)"
  → Displays hint text in blue box below category when clicked
  → Hints auto-clear when word changes or turn ends
  → Server-side: Added handleUseHint function, hintsRemaining tracking
  → Client-side: Smart state management with auto-clear on word change
  → Future ready: Easy to make configurable in lobby settings later
  → See: HINT_FEATURE_SUMMARY.md for implementation details

[DONE - Oct 22, 2025] Restructured word data system
  → Changed from 6 categories (actions, entertainment, food, hobbies, places, things) to 3 categories (Who, Where, What)
  → Single CSV file structure: Word, Category, Hint columns
  → Created conversion script: npm run convert-words
  → Hints now included in word data for hint feature
  → Deleted old CSV files, consolidated to server/data/csv/words.csv
  → See: WORD_SYSTEM_README.md for usage guide

[DONE - Oct 22, 2025] Removed "words remaining" debug text
  → Cleaned up describer view by removing backend caching information
  → Players no longer see "X words remaining" text

[DONE - Oct 16, 2025] Add a longer word list and integrate with the app
  → Converted 6 CSV files (5,029 words total) into words.js with 6 categories: actions, entertainment, food, hobbies, places, things

[DONE - Oct 16, 2025] If someone clicks correct too fast it registers the same word multiple times, fix that
  → Added server-side duplicate detection: checks if the same word was submitted within 2 seconds and ignores duplicates
  → Added client-side debouncing: buttons disabled for 500ms after clicking to prevent rapid multiple clicks
  → Applied fix to both "Correct" and "Skip" buttons

[DONE - Oct 16, 2025] Remove the Get hint button
  → Removed the getHint function and the "Get Hint" button from GameScreen.jsx
  → Cleaned up unused code

[DONE - Oct 16, 2025] Improve the UX of the app for use on mobile devices, particularly making it so most or all screens fit the screen and don't require scrolling
  → Optimized GameScreen: reduced padding, made font sizes responsive (text-3xl sm:text-4xl md:text-5xl), increased viewport height to 95vh on mobile
  → Optimized ReadyScreen: made all sections more compact, reduced spacing, added max-h-[98vh] with scroll for overflow
  → Optimized TurnSummaryScreen: reduced padding and margins, made text responsive, added max-h-[98vh] with scroll
  → All gameplay screens now use responsive breakpoints (sm:, md:) for better mobile experience
  → Reduced button sizes on mobile (py-3 on mobile, py-4 on desktop)
  → Changed "break-all" to "break-words" for better word wrapping
  → Shortened labels ("Skips Remaining" → "Skips", "point(s)" → "pts") to save space


NOTES:
------
- Add new tasks under "ACTIVE TASKS" section

PERFORMANCE IMPROVEMENTS:
--------------------------
[DONE - Oct 16, 2025] Increased debounce times to handle network latency on deployed servers
  → Client-side button debounce: 500ms → 1200ms
  → Server-side duplicate window: 2s → 4s
  → Addresses delay between clicking correct/skip and receiving next word on Railway deployment
  → Future optimization: Consider client-side word preloading for instant feedback

[DONE - Oct 16, 2025] Implemented full word preloading system with optimistic updates
  → Server sends 15-word queue when turn starts (eliminates per-word round trips)
  → Client shows next word INSTANTLY (0ms delay) using local queue
  → Background server updates handle scoring and validation
  → Automatic queue refill: requests 10 more words when 8 words remaining
  → Button debounce reduced to 200ms (from 1200ms) since no server wait needed
  → Server-side: Added wordQueue and queueIndex to currentTurn schema
  → Server-side: Added handleRequestMoreWords with retry logic for race conditions (up to 3 attempts)
  → Client-side: Optimistic state management with automatic sync detection
  → Client-side: Smart queue sync that only updates when server has more words
  → Result: Game feels incredibly responsive, especially on slow connections
  → TESTED: Successfully handled 42+ words in single turn with smooth queue refilling
- Mark completed tasks with [DONE - DATE] and move to "COMPLETED TASKS" section
- Use clear, specific descriptions for each task

