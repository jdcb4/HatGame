BackEndTicky - TODO List
========================
Last Updated: October 26, 2025

ACTIVE TASKS:
-------------
- Further optimize lag reduction (Optional)
  â†’ Goal: Investigate and improve perceived lag between clicking Correct/Skip and seeing next word
  â†’ Current State: 
    * Word preloading system already implemented (should be ~0ms delay)
    * 15-word queue sent at turn start
    * Client shows next word instantly from local queue
    * Server processes in background
    * Auto-refill when â‰¤8 words remaining
  â†’ Potential Issues to Investigate:
    * Is button debouncing too long? (currently 200ms)
    * Network conditions on Railway deployment (2-3s round-trip measured)
    * Are there any blocking operations in client-side word handling?
    * Does score update cause re-render lag?
    * Mobile device performance (primary use case)
    * Is optimistic update working correctly on all devices?
  â†’ Areas to Test:
    * Test on actual mobile devices (not just desktop)
    * Test on slow network (throttle in DevTools)
    * Measure actual delay with console timestamps
    * Check if all browsers handle optimistic updates correctly
    * Test with rapid clicking (multiple words quickly)
  â†’ Potential Improvements:
    * Reduce button debounce if network lag isn't causing issues
    * Add visual feedback animation (word slide out/in) to mask any delay
    * Preload MORE words (currently 15) if queue depletes too fast
    * Use requestAnimationFrame for smoother transitions
    * Optimize React re-renders (useMemo, useCallback)
    * Add haptic feedback on mobile for immediate tactile response
  â†’ Priority: Medium-High (affects core gameplay experience)
  â†’ Note: Already significantly improved from initial 1200ms debounce, but worth revisiting

- Improve "Play Again" Functionality
  â†’ Goal: Create a new game with same players and settings when clicking "Play Again"
  â†’ Current State: Both "Play Again" and "Back to Home" just navigate to home screen (redundant)
  â†’ Desired Behavior:
    * Create new game with same gameSettings from previous game
    * Copy all players from previous game to new game
    * Maintain team assignments from previous game
    * Place everyone in lobby (not auto-start)
    * Allow host to modify settings before starting if desired
    * Handle missing players gracefully:
      - Players who don't rejoin are marked as "pending" or removed
      - Game can still start with remaining players
      - Maybe show "Waiting for [PlayerName]..." with timeout
  â†’ Implementation:
    * Add "rematch" socket action or REST endpoint
    * Backend creates new game, copies settings and player list
    * Backend returns new gameId
    * Frontend navigates all players to new lobby: /lobby/{newGameId}
    * Optional: Add "rejoin" mechanism so missing players can join later
  â†’ UI Considerations:
    * Show loading state while creating rematch
    * Notify players "Starting rematch..." 
    * Handle case where some players left / disconnected
  â†’ Priority: Medium (nice UX improvement, not critical)

- Add "All Play" Feature
  â†’ Goal: Special round where everyone guesses (only one describer)
  â†’ Mechanics:
    * Random trigger or specific frequency (every N turns?)
    * Single word display
    * All players on BOTH teams can guess (except describer)
    * First team to guess correctly wins the points
    * Opposing team can "steal" by guessing correctly
  â†’ UI Changes:
    * Special "ALL PLAY!" screen/indicator
    * All players see word simultaneously (except describer)
    * First correct answer wins
  â†’ Considerations:
    * How to handle simultaneous guesses? (timestamp-based)
    * Point value (higher stakes for All Play?)
    * Should describer rotate normally or stay same?
    * How to trigger: Random chance? Fixed interval? Last turn?
  â†’ Priority: Medium (exciting feature, but complex)
  â†’ Schema: Need to track All Play state in currentTurn

- Add "First to X" Game Mode
  â†’ Goal: Play until one team reaches X points (instead of fixed rounds)
  â†’ Settings:
    * Target score: 10, 15, 20, 25, 30, 50 points
    * Add to game settings: firstToX (boolean), targetScore (number)
  â†’ Logic Changes:
    * Check after each turn if any team >= targetScore
    * End game when condition met (instead of after totalRounds)
    * Still alternate teams as normal
  â†’ UI Changes:
    * Game creation: Toggle "First to X" mode, set target score
    * During game: Show progress toward target (e.g., "15/25")
    * Ready screen: "Next to X points!" instead of "Round Y of Z"
  â†’ Considerations:
    * Should this be a separate app/game type? (Probably not, just a mode)
    * Risk: Requires changes to core game loop (endTurn logic)
    * Testing: Need to ensure no conflicts with existing round-based logic
    * What if teams tie at same score? (Play one more turn? Sudden death?)
  â†’ Priority: Medium (popular request, moderate complexity)
  â†’ CAUTION: Changes affect core game flow - test thoroughly before deploying

- Combine "All Play" + "First to X"
  â†’ Goal: In "First to X" mode, the final turn is always an All Play
  â†’ Mechanics:
    * When a team is 1 turn away from winning (within winning distance)
    * Trigger All Play for dramatic finish
    * Winner-takes-all final round
  â†’ Logic:
    * Check before each turn: is current team close enough to win?
    * If yes, convert next turn to All Play
    * If All Play is won, game over
    * If All Play is lost, continue until someone reaches target
  â†’ Considerations:
    * What's "winning distance"? (1 turn's worth of points? configurable?)
    * Should losing team get a chance to tie? (Fairness)
    * Very exciting for players - high stakes ending
  â†’ Priority: Low (requires both previous features first)
  â†’ Implementation: Build All Play first, then First to X, then combine

- Add Settings Panel for Game Creator
  â†’ Allow host to customize game settings before starting
  â†’ Location: LobbyScreen.jsx (add expandable settings panel)
  â†’ Settings to expose:
    * Turn duration (15s, 30s, 45s, 60s) - currently hardcoded to 30s
    * Total rounds (1-10) - currently hardcoded to 3
    * Skips per turn (0-5) - currently hardcoded to 1
    * Penalty for extra skip (0-3) - currently hardcoded to 1
    * Enable/disable hints - NEW
    * Hints per turn (0-3) - NEW
  â†’ Store in game.gameSettings (already exists, just expose to UI)
  â†’ UI: Collapsible "Game Settings" section in lobby with dropdowns/sliders
  â†’ Mobile: Keep compact, use <select> elements instead of custom dropdowns

- Consider "The Hat Game" Implementation
  â†’ Goal: Similar game where players submit their own words instead of using word database
  â†’ Classic Rules:
    * Each player submits 3-5 words/phrases written on paper ("in the hat")
    * Round 1: Describe word without saying it (like current game)
    * Round 2: Same words, but only ONE WORD clues allowed
    * Round 3: Same words, but CHARADES only (no talking)
    * Points: Team that guesses correctly gets the point
    * All players' words mixed together and used by all teams
  â†’ Key Differences from BackEndTicky:
    * User-generated content instead of database
    * Multiple rounds with SAME words but different rules
    * No categories (just random words)
    * More party-game oriented
  â†’ Implementation Options:
    
    **OPTION A: Separate App (Recommended)**
    Pros:
      âœ… Clean separation of concerns
      âœ… Independent deployment and updates
      âœ… Easier to maintain and debug
      âœ… Can have different branding/UI
      âœ… Users choose which game they want to play
      âœ… Simpler codebase for each game
    Cons:
      âŒ Code duplication (Socket.IO setup, user management, teams)
      âŒ Two separate deployments to maintain
      âŒ Can't easily switch between games mid-session
      âŒ Two separate MongoDB collections/databases
    
    **OPTION B: Multiple Games in One App**
    Pros:
      âœ… Shared infrastructure (Socket.IO, MongoDB, teams, lobby)
      âœ… Single deployment to maintain
      âœ… Could switch game modes in same session
      âœ… Shared UI components and styles
      âœ… One codebase to update
    Cons:
      âŒ More complex codebase (game mode switches everywhere)
      âŒ Harder to test (more conditional logic)
      âŒ Schema needs to support both game types
      âŒ Risk of breaking one game while updating the other
      âŒ Harder for novice coder to understand
    
    **OPTION C: Modular Architecture (Future-Proof)**
    Structure:
      /shared/multiplayer-core/
        - Socket.IO setup, rooms, broadcasting
        - User management (join, leave, teams)
        - Base game schema (id, status, teams, players)
      /games/word-guesser/    (BackEndTicky)
        - Word database and categories
        - Turn logic specific to word guessing
      /games/hat-game/
        - User word submission
        - Multi-round logic (describe/one-word/charades)
      /client/
        - Shared components (Lobby, Teams, Timer)
        - Game-specific components in subfolders
    Pros:
      âœ… Best of both worlds
      âœ… Reusable infrastructure
      âœ… Easy to add more games later
      âœ… Clean separation per game
      âœ… Shared code is actually shared
    Cons:
      âŒ Significant upfront refactoring needed
      âŒ Complex initial setup
      âŒ Overkill if only planning 2 games
      âŒ Harder for novice coder initially
  
  â†’ Recommendation:
    * SHORT TERM: Build as separate app (Option A)
      - Get Hat Game working independently
      - Learn what infrastructure actually needs to be shared
      - Keep BackEndTicky stable and production-ready
    * LONG TERM: If building 3+ games, refactor to modular (Option C)
      - Extract common multiplayer infrastructure
      - Each game becomes a "plugin"
      - Worth the refactoring effort at that point
  
  â†’ Technical Considerations:
    * Hat Game needs: Word submission UI, round tracking, rule changes per round
    * Different timer rules (usually longer rounds)
    * Need to store submitted words per game (not global database)
    * Clear words after game ends (privacy/cleanup)
  
  â†’ Priority: Low (interesting idea, but current game is working well)
  â†’ Next Steps: Build Hat Game as separate repo, reuse learnings from BackEndTicky

- Architecture Refactor: Modular Game System
  â†’ Goal: Extract user management and multiplayer infrastructure so it can be reused for other games
  â†’ Current structure: Everything is tightly coupled to word-guessing game logic
  â†’ Proposed structure:
    /shared/                       # Reusable multiplayer infrastructure
      /models/BaseGame.js          # Common game fields (id, status, teams, players)
      /handlers/userManagement.js  # Join game, join team, leave game
      /handlers/socketSetup.js     # Socket.IO connection, rooms, broadcasting
    /games/
      /word-guesser/               # Current game (BackEndTicky)
        /models/WordGame.js        # Extends BaseGame, adds word-specific fields
        /handlers/wordHandlers.js  # Game-specific logic (start turn, word correct, etc.)
        /data/words.js             # Word lists
      /future-game-1/              # Future game can reuse /shared/
      /future-game-2/
  â†’ Benefits:
    * Reuse user management, team joining, lobby logic
    * Reuse Socket.IO setup and room management
    * Each game only implements its unique gameplay logic
    * Easier to maintain multiple games
  â†’ Considerations:
    * Breaking change - requires significant refactoring
    * Need to ensure backward compatibility with existing database
    * Test thoroughly before deploying
  â†’ Priority: Medium (good for future, but current system works)
  â†’ See ARCHITECTURE.md for current structure before refactoring


COMPLETED TASKS:
----------------
[DONE - Oct 26, 2025] Reduce lag for guessers (Broadcast First, Save Later)
  â†’ Implemented Option 1: Broadcast game updates immediately, save to database in background
  â†’ Created fast versions of handlers: handleWordCorrectFast, handleWordSkipFast, handleUseHintFast
  â†’ Word actions (correct/skip/hint) now broadcast immediately without waiting for MongoDB save
  â†’ Database save happens in background (fire-and-forget with error logging)
  â†’ Expected lag reduction: ~100-500ms â†’ ~10-50ms for guessers
  â†’ Trade-off: Tiny risk of data loss if server crashes between broadcast and save (acceptable)
  â†’ Original handlers kept for reference (not currently used)
  â†’ Files changed: server/index.js
  â†’ Result: All players should now see updates much faster (closer to describer's instant experience)

[DONE - Oct 26, 2025] Auto-save settings when starting game
  â†’ Implemented Option B: Auto-save settings on "Start Game" click
  â†’ If host has settings panel open in edit mode, settings are saved before game starts
  â†’ Added 100ms delay to ensure settings are saved before game initialization
  â†’ File changed: client/src/components/LobbyScreen.jsx (handleStartGame function)
  â†’ Result: No more lost/unsaved settings when starting game

[DONE - Oct 26, 2025] Fixed skip penalty not respecting gameSettings
  â†’ Bug: Penalty was hardcoded to -1 point instead of using gameSettings.penaltyForExtraSkip
  â†’ Solution: Changed handleWordSkip to read penalty value from game.gameSettings.penaltyForExtraSkip
  â†’ File changed: server/index.js (handleWordSkip function)
  â†’ Result: Setting penalty to 0, 2, or 3 points now works correctly

[DONE - Oct 26, 2025] Fixed "Round 4 of 3" display issue after final turn
  â†’ Solution: Conditionally hide round counter in ReadyScreen.jsx when game.status === 'finished'
  â†’ File changed: client/src/components/ReadyScreen.jsx
  â†’ Result: No more confusing round counter after game completes

[DONE - Oct 26, 2025] Added Settings Panel in Lobby
  â†’ Game host can now customize settings before starting game
  â†’ Settings: Turn Duration (15-120s), Total Rounds (1-10), Skips per Turn (0-5), 
    Penalty for Extra Skip (0-3), Hints per Turn (0-5)
  â†’ Host sees "Edit" button with editable form controls
  â†’ Non-host players see read-only display
  â†’ Mobile-friendly using native select/input elements
  â†’ Backend: Added handleUpdateGameSettings with validation
  â†’ Backend: Only allows updates in lobby (before game starts)
  â†’ Files changed: 
    * client/src/components/LobbyScreen.jsx (UI)
    * server/index.js (handler + socket action)
  â†’ Result: Users can customize gameplay without code changes

[DONE - Oct 22, 2025] Fixed turn rotation bug (teams playing twice in a row)
  â†’ Root cause: Concurrent handleEndTurn calls from multiple clients when timer expired
  â†’ Solution: Added concurrency guard (isEndingTurn flag) to prevent duplicate processing
  â†’ Also fixed: Navigation race condition in LobbyScreen (removed duplicate navigate call)
  â†’ Result: Teams now properly alternate with no skipping or double turns
  â†’ See: BUG_ANALYSIS_TURN_ROTATION.md for full technical details

[DONE - Oct 22, 2025] Implemented Hint System
  â†’ Describer gets 2 hints per turn (configurable via gameSettings.hintsPerTurn)
  â†’ Hint button shows remaining hints: "ğŸ’¡ Hint (2)"
  â†’ Displays hint text in blue box below category when clicked
  â†’ Hints auto-clear when word changes or turn ends
  â†’ Server-side: Added handleUseHint function, hintsRemaining tracking
  â†’ Client-side: Smart state management with auto-clear on word change
  â†’ Future ready: Easy to make configurable in lobby settings later
  â†’ See: HINT_FEATURE_SUMMARY.md for implementation details

[DONE - Oct 22, 2025] Restructured word data system
  â†’ Changed from 6 categories (actions, entertainment, food, hobbies, places, things) to 3 categories (Who, Where, What)
  â†’ Single CSV file structure: Word, Category, Hint columns
  â†’ Created conversion script: npm run convert-words
  â†’ Hints now included in word data for hint feature
  â†’ Deleted old CSV files, consolidated to server/data/csv/words.csv
  â†’ See: WORD_SYSTEM_README.md for usage guide

[DONE - Oct 22, 2025] Removed "words remaining" debug text
  â†’ Cleaned up describer view by removing backend caching information
  â†’ Players no longer see "X words remaining" text

[DONE - Oct 16, 2025] Add a longer word list and integrate with the app
  â†’ Converted 6 CSV files (5,029 words total) into words.js with 6 categories: actions, entertainment, food, hobbies, places, things

[DONE - Oct 16, 2025] If someone clicks correct too fast it registers the same word multiple times, fix that
  â†’ Added server-side duplicate detection: checks if the same word was submitted within 2 seconds and ignores duplicates
  â†’ Added client-side debouncing: buttons disabled for 500ms after clicking to prevent rapid multiple clicks
  â†’ Applied fix to both "Correct" and "Skip" buttons

[DONE - Oct 16, 2025] Remove the Get hint button
  â†’ Removed the getHint function and the "Get Hint" button from GameScreen.jsx
  â†’ Cleaned up unused code

[DONE - Oct 16, 2025] Improve the UX of the app for use on mobile devices, particularly making it so most or all screens fit the screen and don't require scrolling
  â†’ Optimized GameScreen: reduced padding, made font sizes responsive (text-3xl sm:text-4xl md:text-5xl), increased viewport height to 95vh on mobile
  â†’ Optimized ReadyScreen: made all sections more compact, reduced spacing, added max-h-[98vh] with scroll for overflow
  â†’ Optimized TurnSummaryScreen: reduced padding and margins, made text responsive, added max-h-[98vh] with scroll
  â†’ All gameplay screens now use responsive breakpoints (sm:, md:) for better mobile experience
  â†’ Reduced button sizes on mobile (py-3 on mobile, py-4 on desktop)
  â†’ Changed "break-all" to "break-words" for better word wrapping
  â†’ Shortened labels ("Skips Remaining" â†’ "Skips", "point(s)" â†’ "pts") to save space


NOTES:
------
- Add new tasks under "ACTIVE TASKS" section

PERFORMANCE IMPROVEMENTS:
--------------------------
[DONE - Oct 16, 2025] Increased debounce times to handle network latency on deployed servers
  â†’ Client-side button debounce: 500ms â†’ 1200ms
  â†’ Server-side duplicate window: 2s â†’ 4s
  â†’ Addresses delay between clicking correct/skip and receiving next word on Railway deployment
  â†’ Future optimization: Consider client-side word preloading for instant feedback

[DONE - Oct 16, 2025] Implemented full word preloading system with optimistic updates
  â†’ Server sends 15-word queue when turn starts (eliminates per-word round trips)
  â†’ Client shows next word INSTANTLY (0ms delay) using local queue
  â†’ Background server updates handle scoring and validation
  â†’ Automatic queue refill: requests 10 more words when 8 words remaining
  â†’ Button debounce reduced to 200ms (from 1200ms) since no server wait needed
  â†’ Server-side: Added wordQueue and queueIndex to currentTurn schema
  â†’ Server-side: Added handleRequestMoreWords with retry logic for race conditions (up to 3 attempts)
  â†’ Client-side: Optimistic state management with automatic sync detection
  â†’ Client-side: Smart queue sync that only updates when server has more words
  â†’ Result: Game feels incredibly responsive, especially on slow connections
  â†’ TESTED: Successfully handled 42+ words in single turn with smooth queue refilling
- Mark completed tasks with [DONE - DATE] and move to "COMPLETED TASKS" section
- Use clear, specific descriptions for each task

